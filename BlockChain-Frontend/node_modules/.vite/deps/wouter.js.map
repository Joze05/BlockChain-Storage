{
  "version": 3,
  "sources": ["../../wouter/react-deps.js", "../../wouter/use-location.js", "../../wouter/matcher.js", "../../wouter/index.js", "dep:wouter"],
  "sourcesContent": ["export {\r\n  useRef,\r\n  useEffect,\r\n  useLayoutEffect,\r\n  useState,\r\n  useContext,\r\n  useCallback,\r\n  createContext,\r\n  isValidElement,\r\n  cloneElement,\r\n  createElement,\r\n  Fragment,\r\n} from \"react\";\r\n", "import { useEffect, useRef, useState, useCallback } from \"./react-deps.js\";\r\n\r\n/**\r\n * History API docs @see https://developer.mozilla.org/en-US/docs/Web/API/History\r\n */\r\nconst eventPopstate = \"popstate\";\r\nconst eventPushState = \"pushState\";\r\nconst eventReplaceState = \"replaceState\";\r\nexport const events = [eventPopstate, eventPushState, eventReplaceState];\r\n\r\nexport default ({ base = \"\" } = {}) => {\r\n  const [{ path, search }, update] = useState(() => ({\r\n    path: currentPathname(base),\r\n    search: location.search,\r\n  })); // @see https://reactjs.org/docs/hooks-reference.html#lazy-initial-state\r\n  const prevHash = useRef(path + search);\r\n\r\n  useEffect(() => {\r\n    // this function checks if the location has been changed since the\r\n    // last render and updates the state only when needed.\r\n    // unfortunately, we can't rely on `path` value here, since it can be stale,\r\n    // that's why we store the last pathname in a ref.\r\n    const checkForUpdates = () => {\r\n      const pathname = currentPathname(base);\r\n      const search = location.search;\r\n      const hash = pathname + search;\r\n\r\n      if (prevHash.current !== hash) {\r\n        prevHash.current = hash;\r\n        update({ path: pathname, search });\r\n      }\r\n    };\r\n\r\n    events.forEach((e) => addEventListener(e, checkForUpdates));\r\n\r\n    // it's possible that an update has occurred between render and the effect handler,\r\n    // so we run additional check on mount to catch these updates. Based on:\r\n    // https://gist.github.com/bvaughn/e25397f70e8c65b0ae0d7c90b731b189\r\n    checkForUpdates();\r\n\r\n    return () => events.forEach((e) => removeEventListener(e, checkForUpdates));\r\n  }, [base]);\r\n\r\n  // the 2nd argument of the `useLocation` return value is a function\r\n  // that allows to perform a navigation.\r\n  //\r\n  // the function reference should stay the same between re-renders, so that\r\n  // it can be passed down as an element prop without any performance concerns.\r\n  const navigate = useCallback(\r\n    (to, { replace = false } = {}) =>\r\n      history[replace ? eventReplaceState : eventPushState](\r\n        null,\r\n        \"\",\r\n        // handle nested routers and absolute paths\r\n        to[0] === \"~\" ? to.slice(1) : base + to\r\n      ),\r\n    [base]\r\n  );\r\n\r\n  return [path, navigate];\r\n};\r\n\r\n// While History API does have `popstate` event, the only\r\n// proper way to listen to changes via `push/replaceState`\r\n// is to monkey-patch these methods.\r\n//\r\n// See https://stackoverflow.com/a/4585031\r\nif (typeof history !== \"undefined\") {\r\n  for (const type of [eventPushState, eventReplaceState]) {\r\n    const original = history[type];\r\n\r\n    history[type] = function () {\r\n      const result = original.apply(this, arguments);\r\n      const event = new Event(type);\r\n      event.arguments = arguments;\r\n\r\n      dispatchEvent(event);\r\n      return result;\r\n    };\r\n  }\r\n}\r\n\r\nconst currentPathname = (base, path = location.pathname) =>\r\n  !path.toLowerCase().indexOf(base.toLowerCase())\r\n    ? path.slice(base.length) || \"/\"\r\n    : \"~\" + path;\r\n", "// creates a matcher function\r\nexport default function makeMatcher(makeRegexpFn = pathToRegexp) {\r\n  let cache = {};\r\n\r\n  // obtains a cached regexp version of the pattern\r\n  const getRegexp = (pattern) =>\r\n    cache[pattern] || (cache[pattern] = makeRegexpFn(pattern));\r\n\r\n  return (pattern, path) => {\r\n    const { regexp, keys } = getRegexp(pattern || \"\");\r\n    const out = regexp.exec(path);\r\n\r\n    if (!out) return [false, null];\r\n\r\n    // formats an object with matched params\r\n    const params = keys.reduce((params, key, i) => {\r\n      params[key.name] = out[i + 1];\r\n      return params;\r\n    }, {});\r\n\r\n    return [true, params];\r\n  };\r\n}\r\n\r\n// escapes a regexp string (borrowed from path-to-regexp sources)\r\n// https://github.com/pillarjs/path-to-regexp/blob/v3.0.0/index.js#L202\r\nconst escapeRx = (str) => str.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, \"\\\\$1\");\r\n\r\n// returns a segment representation in RegExp based on flags\r\n// adapted and simplified version from path-to-regexp sources\r\nconst rxForSegment = (repeat, optional, prefix) => {\r\n  let capture = repeat ? \"((?:[^\\\\/]+?)(?:\\\\/(?:[^\\\\/]+?))*)\" : \"([^\\\\/]+?)\";\r\n  if (optional && prefix) capture = \"(?:\\\\/\" + capture + \")\";\r\n  return capture + (optional ? \"?\" : \"\");\r\n};\r\n\r\nconst pathToRegexp = (pattern) => {\r\n  const groupRx = /:([A-Za-z0-9_]+)([?+*]?)/g;\r\n\r\n  let match = null,\r\n    lastIndex = 0,\r\n    keys = [],\r\n    result = \"\";\r\n\r\n  while ((match = groupRx.exec(pattern)) !== null) {\r\n    const [_, segment, mod] = match;\r\n\r\n    // :foo  [1]      (  )\r\n    // :foo? [0 - 1]  ( o)\r\n    // :foo+ [1 - \u221E]  (r )\r\n    // :foo* [0 - \u221E]  (ro)\r\n    const repeat = mod === \"+\" || mod === \"*\";\r\n    const optional = mod === \"?\" || mod === \"*\";\r\n    const prefix = optional && pattern[match.index - 1] === \"/\" ? 1 : 0;\r\n\r\n    const prev = pattern.substring(lastIndex, match.index - prefix);\r\n\r\n    keys.push({ name: segment });\r\n    lastIndex = groupRx.lastIndex;\r\n\r\n    result += escapeRx(prev) + rxForSegment(repeat, optional, prefix);\r\n  }\r\n\r\n  result += escapeRx(pattern.substring(lastIndex));\r\n  return { keys, regexp: new RegExp(\"^\" + result + \"(?:\\\\/)?$\", \"i\") };\r\n};\r\n", "import locationHook from \"./use-location.js\";\r\nimport makeMatcher from \"./matcher.js\";\r\n\r\nimport {\r\n  useRef,\r\n  useLayoutEffect,\r\n  useContext,\r\n  useCallback,\r\n  createContext,\r\n  isValidElement,\r\n  cloneElement,\r\n  createElement as h,\r\n  Fragment,\r\n} from \"./react-deps.js\";\r\n\r\n/*\r\n * Part 1, Hooks API: useRouter, useRoute and useLocation\r\n */\r\n\r\n// one of the coolest features of `createContext`:\r\n// when no value is provided \u2014 default object is used.\r\n// allows us to use the router context as a global ref to store\r\n// the implicitly created router (see `useRouter` below)\r\nconst RouterCtx = createContext({});\r\n\r\nconst buildRouter = ({\r\n  hook = locationHook,\r\n  base = \"\",\r\n  matcher = makeMatcher(),\r\n} = {}) => ({ hook, base, matcher });\r\n\r\nexport const useRouter = () => {\r\n  const globalRef = useContext(RouterCtx);\r\n\r\n  // either obtain the router from the outer context (provided by the\r\n  // `<Router /> component) or create an implicit one on demand.\r\n  return globalRef.v || (globalRef.v = buildRouter());\r\n};\r\n\r\nexport const useLocation = () => {\r\n  const router = useRouter();\r\n  return router.hook(router);\r\n};\r\n\r\nexport const useRoute = (pattern) => {\r\n  const [path] = useLocation();\r\n  return useRouter().matcher(pattern, path);\r\n};\r\n\r\n// internal hook used by Link and Redirect in order to perform navigation\r\nconst useNavigate = (options) => {\r\n  const navRef = useRef();\r\n  const [, navigate] = useLocation();\r\n\r\n  navRef.current = () => navigate(options.to || options.href, options);\r\n  return navRef;\r\n};\r\n\r\n/*\r\n * Part 2, Low Carb Router API: Router, Route, Link, Switch\r\n */\r\n\r\nexport const Router = (props) => {\r\n  const ref = useRef();\r\n\r\n  // this little trick allows to avoid having unnecessary\r\n  // calls to potentially expensive `buildRouter` method.\r\n  // https://reactjs.org/docs/hooks-faq.html#how-to-create-expensive-objects-lazily\r\n  const value = ref.current || (ref.current = { v: buildRouter(props) });\r\n\r\n  return h(RouterCtx.Provider, {\r\n    value,\r\n    children: props.children,\r\n  });\r\n};\r\n\r\nexport const Route = ({ path, match, component, children }) => {\r\n  const useRouteMatch = useRoute(path);\r\n\r\n  // `props.match` is present - Route is controlled by the Switch\r\n  const [matches, params] = match || useRouteMatch;\r\n\r\n  if (!matches) return null;\r\n\r\n  // React-Router style `component` prop\r\n  if (component) return h(component, { params });\r\n\r\n  // support render prop or plain children\r\n  return typeof children === \"function\" ? children(params) : children;\r\n};\r\n\r\nexport const Link = (props) => {\r\n  const navRef = useNavigate(props);\r\n  const { base } = useRouter();\r\n\r\n  let { to, href = to, children, onClick } = props;\r\n\r\n  const handleClick = useCallback(\r\n    (event) => {\r\n      // ignores the navigation when clicked using right mouse button or\r\n      // by holding a special modifier key: ctrl, command, win, alt, shift\r\n      if (\r\n        event.ctrlKey ||\r\n        event.metaKey ||\r\n        event.altKey ||\r\n        event.shiftKey ||\r\n        event.button !== 0\r\n      )\r\n        return;\r\n\r\n      event.preventDefault();\r\n      navRef.current();\r\n      onClick && onClick(event);\r\n    },\r\n    // navRef is a ref so it never changes\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n    [onClick]\r\n  );\r\n\r\n  // wraps children in `a` if needed\r\n  const extraProps = {\r\n    // handle nested routers and absolute paths\r\n    href: href[0] === \"~\" ? href.slice(1) : base + href,\r\n    onClick: handleClick,\r\n    to: null,\r\n  };\r\n  const jsx = isValidElement(children) ? children : h(\"a\", props);\r\n\r\n  return cloneElement(jsx, extraProps);\r\n};\r\n\r\nconst flattenChildren = (children) => {\r\n  return Array.isArray(children)\r\n    ? [].concat(\r\n        ...children.map((c) =>\r\n          c && c.type === Fragment\r\n            ? flattenChildren(c.props.children)\r\n            : flattenChildren(c)\r\n        )\r\n      )\r\n    : [children];\r\n};\r\n\r\nexport const Switch = ({ children, location }) => {\r\n  const { matcher } = useRouter();\r\n  const [originalLocation] = useLocation();\r\n\r\n  for (const element of flattenChildren(children)) {\r\n    let match = 0;\r\n\r\n    if (\r\n      isValidElement(element) &&\r\n      // we don't require an element to be of type Route,\r\n      // but we do require it to contain a truthy `path` prop.\r\n      // this allows to use different components that wrap Route\r\n      // inside of a switch, for example <AnimatedRoute />.\r\n      (match = element.props.path\r\n        ? matcher(element.props.path, location || originalLocation)\r\n        : [true, {}])[0]\r\n    )\r\n      return cloneElement(element, { match });\r\n  }\r\n\r\n  return null;\r\n};\r\n\r\nexport const Redirect = (props) => {\r\n  const navRef = useNavigate(props);\r\n\r\n  // empty array means running the effect once, navRef is a ref so it never changes\r\n  useLayoutEffect(() => {\r\n    navRef.current();\r\n  }, []); // eslint-disable-line react-hooks/exhaustive-deps\r\n\r\n  return null;\r\n};\r\n\r\nexport default useRoute;\r\n", "import d from \"./node_modules/wouter/index.js\";export default d;\nexport * from \"./node_modules/wouter/index.js\""],
  "mappings": "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",
  "names": []
}
